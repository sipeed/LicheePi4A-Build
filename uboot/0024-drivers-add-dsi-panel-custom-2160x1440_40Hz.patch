From f30fbe921d25798df094898b54a228059398b20e Mon Sep 17 00:00:00 2001
From: Lu Hui <luhui@sipeed.com>
Date: Mon, 27 Nov 2023 18:05:16 +0800
Subject: [PATCH 24/24] drivers: add dsi panel custom-2160x1440_40Hz

---
 drivers/video/Kconfig                 |   8 +
 drivers/video/Makefile                |   1 +
 drivers/video/custom-2160x1440_40Hz.c | 216 ++++++++++++++++++++++++++
 3 files changed, 225 insertions(+)
 create mode 100644 drivers/video/custom-2160x1440_40Hz.c

diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 5a85ce6e..8fd18394 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -359,6 +359,14 @@ config VIDEO_LCD_MINGJUN_070BI30IA2
 	Say Y here if you want to enable support for Mingjun 070BI30IA2
 	800x1280 DSI video mode panel.
 
+config VIDEO_LCD_CUSTOM_2160X1440_40HZ
+        bool "custom 2160x1440_40Hz DSI LCD panel support"
+        depends on DM_VIDEO
+        select VIDEO_MIPI_DSI
+        help
+        Say Y here if you want to enable support for custom
+        2160x1440_40Hz DSI video mode panel.
+
 config VIDEO_LCD_CUSTOM_LOGO
 	bool "LCD CUSTOM logo support"
 	default n
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 42885a6c..142029af 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -56,6 +56,7 @@ obj-$(CONFIG_VIDEO_LCD_ORISETECH_OTM8009A) += orisetech_otm8009a.o
 obj-$(CONFIG_VIDEO_LCD_RAYDIUM_RM68200) += raydium-rm68200.o
 obj-$(CONFIG_VIDEO_LCD_ILITEK_ILI9881C) += ilitek-ili9881c.o
 obj-$(CONFIG_VIDEO_LCD_MINGJUN_070BI30IA2) += mingjun-070bi30ia2.o
+obj-$(CONFIG_VIDEO_LCD_CUSTOM_2160X1440_40HZ) += custom-2160x1440_40Hz.o
 obj-$(CONFIG_VIDEO_LCD_SSD2828) += ssd2828.o
 obj-$(CONFIG_VIDEO_MB862xx) += mb862xx.o videomodes.o
 obj-${CONFIG_VIDEO_MESON} += meson/
diff --git a/drivers/video/custom-2160x1440_40Hz.c b/drivers/video/custom-2160x1440_40Hz.c
new file mode 100644
index 00000000..b96ac9c6
--- /dev/null
+++ b/drivers/video/custom-2160x1440_40Hz.c
@@ -0,0 +1,216 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <common.h>
+#include <backlight.h>
+#include <dm.h>
+#include <mipi_dsi.h>
+#include <panel.h>
+#include <asm/gpio.h>
+
+struct custom2160x1440_40Hz_desc {
+	const struct display_timing *timing;
+};
+
+struct custom2160x1440_40Hz_panel_priv {
+	struct udevice *backlight;
+	struct gpio_desc reset;
+	const struct custom2160x1440_40Hz_desc *desc;
+};
+
+static const struct display_timing custom2160x1440_40Hz_timing = {
+	.pixelclock.typ		= 136000000,
+	.hactive.typ		= 2160,
+	.hfront_porch.typ	= 48,
+	.hback_porch.typ	= 80,
+	.hsync_len.typ		= 32,
+	.vactive.typ		= 1440,
+	.vfront_porch.typ	= 3,
+	.vback_porch.typ	= 14,
+	.vsync_len.typ		= 10,
+	.flags			= DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
+};
+
+static int custom2160x1440_40Hz_panel_setup(struct udevice *panel)
+{
+	int ret;
+	u8 power_mode;
+	const struct custom2160x1440_40Hz_instr *instr;
+	struct custom2160x1440_40Hz_panel_priv *priv = dev_get_priv(panel);
+	struct mipi_dsi_panel_plat *plat = dev_get_platdata(panel);
+	struct mipi_dsi_device *dsi = plat->device;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	/* sanity test for connection */
+	ret = mipi_dsi_dcs_get_power_mode(dsi, &power_mode);
+	if (ret) {
+		dev_warn(dsi->dev, "%s: failed to get power mode: %d\n", __func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int custom2160x1440_40Hz_panel_prepare(struct udevice *panel)
+{
+	struct custom2160x1440_40Hz_panel_priv *priv = dev_get_priv(panel);
+	int ret;
+
+	/* reset panel */
+	ret = dm_gpio_set_value(&priv->reset, true);
+	if (ret)
+		return ret;
+	mdelay(1);
+
+	ret = dm_gpio_set_value(&priv->reset, false);
+	if (ret)
+		return ret;
+	mdelay(10);
+
+	return 0;
+}
+
+static int custom2160x1440_40Hz_panel_enable(struct udevice *panel)
+{
+	int ret;
+	struct custom2160x1440_40Hz_panel_priv *priv = dev_get_priv(panel);
+	struct mipi_dsi_panel_plat *plat = dev_get_platdata(panel);
+	struct mipi_dsi_device *dsi = plat->device;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret)
+		return ret;
+
+	mdelay(10);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret)
+		return ret;
+
+#if 0
+	ret = backlight_enable(priv->backlight);
+	if (ret)
+		return ret;
+#endif
+
+	return 0;
+}
+
+static int custom2160x1440_40Hz_panel_enable_backlight(struct udevice *dev)
+{
+	int ret;
+	struct mipi_dsi_panel_plat *plat = dev_get_platdata(dev);
+	struct mipi_dsi_device *device = plat->device;
+
+	ret = mipi_dsi_attach(device);
+	if (ret < 0)
+		return ret;
+
+	ret = custom2160x1440_40Hz_panel_setup(dev);
+	if (ret)
+		return ret;
+
+	ret = custom2160x1440_40Hz_panel_enable(dev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int custom2160x1440_40Hz_panel_get_display_timing(struct udevice *dev,
+					     struct display_timing *timings)
+{
+	struct mipi_dsi_panel_plat *plat = dev_get_platdata(dev);
+	struct mipi_dsi_device *device = plat->device;
+	struct custom2160x1440_40Hz_panel_priv *priv = dev_get_priv(dev);
+
+	memcpy(timings, priv->desc->timing, sizeof(*timings));
+
+	device->lanes	= 4;
+	device->format	= MIPI_DSI_FMT_RGB888;
+	//device->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST;
+	//device->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+	device->mode_flags = MIPI_DSI_MODE_VIDEO;
+
+	return 0;
+}
+
+static int custom2160x1440_40Hz_panel_ofdata_to_platdata(struct udevice *dev)
+{
+	struct custom2160x1440_40Hz_panel_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = gpio_request_by_name(dev, "reset-gpios", 0,
+			&priv->reset, GPIOD_IS_OUT);
+	if (ret) {
+		dev_err(dev, "Warning: cannot get reset GPIO\n");
+		return ret;
+	}
+
+	ret = uclass_get_device_by_phandle(UCLASS_PANEL_BACKLIGHT, dev,
+					   "backlight", &priv->backlight);
+	if (ret) {
+		dev_err(dev, "Cannot get backlight: ret=%d\n", ret);
+	}
+
+	/* TODO: get lanes, format and mode from dtb */
+
+	return 0;
+}
+
+static int custom2160x1440_40Hz_panel_probe(struct udevice *panel)
+{
+	int ret;
+	struct custom2160x1440_40Hz_panel_priv *priv = dev_get_priv(panel);
+
+	priv->desc = (const struct custom2160x1440_40Hz_desc *)dev_get_driver_data(panel);
+
+	printf("dsi panel: custom 2160x1440 40Hz\n\r");
+	/* prepare_panel */
+	ret = custom2160x1440_40Hz_panel_prepare(panel);
+	if (ret) {
+		dev_err(panel, "failed to prepare panel : %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int custom2160x1440_40Hz_panel_remove(struct udevice *panel)
+{
+	struct custom2160x1440_40Hz_panel_priv *priv = dev_get_priv(panel);
+
+	return dm_gpio_set_value(&priv->reset, true);
+}
+
+static const struct custom2160x1440_40Hz_desc custom2160x1440_40Hz_desc = {
+        .timing = &custom2160x1440_40Hz_timing,
+};
+
+static const struct panel_ops custom2160x1440_40Hz_panel_ops = {
+	.enable_backlight	= custom2160x1440_40Hz_panel_enable_backlight,
+	.get_display_timing	= custom2160x1440_40Hz_panel_get_display_timing,
+};
+
+static const struct udevice_id custom2160x1440_40Hz_panel_ids[] = {
+	{ .compatible = "custom,2160x1440_40Hz", .data = (ulong)&custom2160x1440_40Hz_desc },
+	{ /* sentinel */ }
+};
+
+U_BOOT_DRIVER(custom2160x1440_40Hz_panel) = {
+	.name 			  = "custom2160x1440_40Hz_panel",
+	.id			  = UCLASS_PANEL,
+	.of_match		  = custom2160x1440_40Hz_panel_ids,
+	.ops			  = &custom2160x1440_40Hz_panel_ops,
+	.ofdata_to_platdata	  = custom2160x1440_40Hz_panel_ofdata_to_platdata,
+	.probe			  = custom2160x1440_40Hz_panel_probe,
+	.remove			  = custom2160x1440_40Hz_panel_remove,
+	.platdata_auto_alloc_size = sizeof(struct mipi_dsi_panel_plat),
+	.priv_auto_alloc_size	  = sizeof(struct custom2160x1440_40Hz_panel_priv),
+};
-- 
2.34.1

