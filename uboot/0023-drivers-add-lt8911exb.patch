From ea6e3f465b0c266d48f0624b90f3c280cfb0d359 Mon Sep 17 00:00:00 2001
From: Lu Hui <luhui@sipeed.com>
Date: Mon, 27 Nov 2023 18:04:46 +0800
Subject: [PATCH 23/24] drivers: add lt8911exb

---
 drivers/video/bridge/Kconfig      |   9 +
 drivers/video/bridge/Makefile     |   1 +
 drivers/video/bridge/lt8911exb.c  | 709 ++++++++++++++++++++++++++++++
 drivers/video/bridge/lt8911exb.ce | 422 ++++++++++++++++++
 4 files changed, 1141 insertions(+)
 create mode 100644 drivers/video/bridge/lt8911exb.c
 create mode 100644 drivers/video/bridge/lt8911exb.ce

diff --git a/drivers/video/bridge/Kconfig b/drivers/video/bridge/Kconfig
index 765f7380..d00a880a 100644
--- a/drivers/video/bridge/Kconfig
+++ b/drivers/video/bridge/Kconfig
@@ -33,3 +33,12 @@ config VIDEO_BRIDGE_ANALOGIX_ANX6345
 	help
 	 The Analogix ANX6345 is RGB-to-DP converter. It enables an eDP LCD
 	 panel to be connected to an parallel LCD interface.
+
+config VIDEO_BRIDGE_LONTIUM_LT8911EXB
+        bool "Support Lontium lt8911exb MIPI->eDP bridge"
+        depends on VIDEO_BRIDGE
+        select DM_I2C
+        help
+         The lontium lt8911exb is MIPI-to-DP converter. It enables an eDP LCD
+         panel to be connected to an mipi LCD interface.
+
diff --git a/drivers/video/bridge/Makefile b/drivers/video/bridge/Makefile
index 45e54ac1..7e61c3eb 100644
--- a/drivers/video/bridge/Makefile
+++ b/drivers/video/bridge/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_VIDEO_BRIDGE) += video-bridge-uclass.o
 obj-$(CONFIG_VIDEO_BRIDGE_PARADE_PS862X) += ps862x.o
 obj-$(CONFIG_VIDEO_BRIDGE_NXP_PTN3460) += ptn3460.o
 obj-$(CONFIG_VIDEO_BRIDGE_ANALOGIX_ANX6345) += anx6345.o
+obj-$(CONFIG_VIDEO_BRIDGE_LONTIUM_LT8911EXB) += lt8911exb.o
diff --git a/drivers/video/bridge/lt8911exb.c b/drivers/video/bridge/lt8911exb.c
new file mode 100644
index 00000000..9154cde8
--- /dev/null
+++ b/drivers/video/bridge/lt8911exb.c
@@ -0,0 +1,709 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2017 Vasily Khoruzhick <anarsoul@gmail.com>
+ * Copyright (C) 2016-2017 Topband. ltd.
+ * Copyright (C) 2023 Sipeed.
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <video_bridge.h>
+
+#define LT8911EXB_I2C_NAME      "lt8911exb"
+#define LT8911EXB_DRIVER_VERSION  "1.0.0"
+
+#define LT8911EXB_ADDR_LENGTH      1
+#define I2C_MAX_TRANSFER_SIZE   255
+#define RETRY_MAX_TIMES         3
+
+struct lt8911exb_priv {
+        int hact;
+        int vact;
+        int hbp;
+        int hfp;
+        int hs;
+        int vbp;
+        int vfp;
+        int vs;
+        int pclk;
+        int htotal;
+        int vtotal;
+
+        int lane_cnt;
+        int mipi_lane;
+        int color;              //Color Depth 0:6bit 1:8bit
+        int test;
+};
+
+
+static int lt8911exb_write0(struct udevice *dev, unsigned int addr_off,
+			 unsigned char reg_addr, unsigned char value)
+{
+	uint8_t buf[2];
+	struct i2c_msg msg;
+	int ret;
+
+	msg.addr = addr_off;
+	msg.flags = 0;
+	buf[0] = reg_addr;
+	buf[1] = value;
+	msg.buf = buf;
+	msg.len = 2;
+	ret = dm_i2c_xfer(dev, &msg, 1);
+	if (ret) {
+		debug("%s: write failed, reg=%#x, value=%#x, ret=%d\n",
+		      __func__, reg_addr, value, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int lt8911exb_read0(struct udevice *dev, unsigned int addr_off,
+			unsigned char reg_addr, unsigned char *value)
+{
+	uint8_t addr, val;
+	struct i2c_msg msg[2];
+	int ret;
+
+	msg[0].addr = addr_off;
+	msg[0].flags = 0;
+	addr = reg_addr;
+	msg[0].buf = &addr;
+	msg[0].len = 1;
+	msg[1].addr = addr_off;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = &val;
+	msg[1].len = 1;
+	ret = dm_i2c_xfer(dev, msg, 2);
+	if (ret) {
+		debug("%s: read failed, reg=%.2x, value=%p, ret=%d\n",
+		      __func__, (int)reg_addr, value, ret);
+		return ret;
+	}
+	*value = val;
+
+	return 0;
+}
+
+static int lt8911exb_write(struct udevice *dev, unsigned char reg_addr,
+			    unsigned char value)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+
+	return lt8911exb_write0(dev, chip->chip_addr, reg_addr, value);
+}
+
+static u8 lt8911exb_read(struct udevice *dev, unsigned char reg_addr)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+	u8 data;
+	lt8911exb_read0(dev, chip->chip_addr, reg_addr, &data);
+	return data;
+}
+
+static int lt8911exb_set_backlight(struct udevice *dev, int percent)
+{
+	/* No-op */
+	return 0;
+}
+
+static int lt8911exb_attach(struct udevice *dev)
+{
+	/* No-op */
+	return 0;
+}
+
+static int lt8911exb_parse_dt(struct udevice *dev)
+{
+	struct lt8911exb_priv *lt8911exb = dev_get_priv(dev);
+	int ret = 0;
+
+	lt8911exb->hact = 2160;
+	lt8911exb->vact = 1440;
+	lt8911exb->hbp = 80;
+	lt8911exb->hfp = 48;
+	lt8911exb->hs = 32;
+	lt8911exb->vbp = 14;
+	lt8911exb->vfp = 3;
+	lt8911exb->vs = 10;
+	lt8911exb->pclk = 136000000;
+	lt8911exb->pclk /= 10000; // 10khz
+	lt8911exb->color = 1; // 0:6bit 1:8bit
+	lt8911exb->lane_cnt = 2;
+	lt8911exb->mipi_lane = 2;
+	lt8911exb->test = 0;
+
+	lt8911exb->htotal = lt8911exb->hact + lt8911exb->hbp + lt8911exb->hfp + lt8911exb->hs;
+	lt8911exb->vtotal = lt8911exb->vact + lt8911exb->vbp + lt8911exb->vfp + lt8911exb->vs;
+	return 0;
+}
+
+static int lt8911exb_i2c_test(struct udevice *dev)
+{
+	u8 retry = 0;
+	u8 chip_id_h = 0, chip_id_m = 0, chip_id_l = 0;
+	int ret = -EAGAIN;
+
+	while (retry++ < 3) {
+		ret = lt8911exb_write(dev, 0xff, 0x81);
+
+		if (ret < 0) {
+			printf(
+				"LT8911EXB i2c test write addr:0xff failed\n\r");
+			continue;
+		}
+
+		ret = lt8911exb_write(dev, 0x08, 0x7f);
+
+		if (ret < 0) {
+			printf(
+				"LT8911EXB i2c test write addr:0x08 failed\n\r");
+			continue;
+		}
+
+		chip_id_l = lt8911exb_read(dev, 0x00);
+		chip_id_m = lt8911exb_read(dev, 0x01);
+		chip_id_h = lt8911exb_read(dev, 0x02);
+		// LT8911EXB i2c test success chipid: 0xe0517
+		printf(
+			 "LT8911EXB i2c test success chipid: 0x%x%x%x\n\r",
+			 chip_id_h, chip_id_m, chip_id_l);
+
+		//        if (chip_id_h == 0 && chip_id_l == 0) {
+		//            printf( "LT8911EXB i2c test failed time %d\n\r", retry);
+		//            continue;
+		//        }
+
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+void lt8911exb_dpcd_write(struct udevice *dev, u32 address, u8 Data)
+{
+	u8 address_h = 0x0f & (address >> 16);
+	u8 address_m = 0xff & (address >> 8);
+	u8 address_l = 0xff & address;
+	u8 ret = 0x00;
+
+	lt8911exb_write(dev, 0xff, 0xa6);
+	lt8911exb_write(dev, 0x2b, (0x80 | address_h));
+	lt8911exb_write(dev, 0x2b, address_m);	//addr[15:8]
+	lt8911exb_write(dev, 0x2b, address_l);	//addr[7:0]
+	lt8911exb_write(dev, 0x2b, 0x00);	//data lenth
+	lt8911exb_write(dev, 0x2b, Data);	//data
+	lt8911exb_write(dev, 0x2c, 0x00);	//start Aux read edid
+
+	mdelay(20);
+	ret = lt8911exb_read(dev, 0x25);
+
+	if ((ret & 0x0f) == 0x0c) {
+		return;
+	}
+}
+
+u8 lt8911exb_dpcd_read(struct udevice *dev, u32 address)
+{
+	u8 read_cnt = 0x03;
+	u8 dpcd_value = 0x00;
+	u8 address_h = 0x0f & (address >> 16);
+	u8 address_m = 0xff & (address >> 8);
+	u8 address_l = 0xff & address;
+
+	lt8911exb_write(dev, 0xff, 0x80);
+	lt8911exb_write(dev, 0x62, 0xbd);
+	lt8911exb_write(dev, 0x62, 0xbf);	//ECO(AUX reset)
+
+	lt8911exb_write(dev, 0x36, 0x00);
+	lt8911exb_write(dev, 0x30, 0x8f);	//0x91
+	lt8911exb_write(dev, 0x33, address_l);
+	lt8911exb_write(dev, 0x34, address_m);
+	lt8911exb_write(dev, 0x35, address_h);
+	lt8911exb_write(dev, 0x36, 0x20);
+
+	mdelay(2);		//The necessary
+
+	if (lt8911exb_read(dev, 0x39) == 0x01) {
+		dpcd_value = lt8911exb_read(dev, 0x38);
+	} else {
+		while ((lt8911exb_read(dev, 0x39) != 0x01) && (read_cnt > 0)) {
+			lt8911exb_write(dev, 0x36, 0x00);
+			lt8911exb_write(dev, 0x36, 0x20);
+			read_cnt--;
+			mdelay(2);
+		}
+
+		if (lt8911exb_read(dev, 0x39) == 0x01) {
+			dpcd_value = lt8911exb_read(dev, 0x38);
+		}
+	}
+
+	return dpcd_value;
+}
+
+void lt8911exb_mipi_video_timing(struct udevice *dev)
+{
+	struct lt8911exb_priv *lt8911exb = dev_get_priv(dev);
+
+	lt8911exb_write(dev, 0xff, 0xd0);
+	lt8911exb_write(dev, 0x0d, (u8) (lt8911exb->vtotal / 256));
+	lt8911exb_write(dev, 0x0e, (u8) (lt8911exb->vtotal % 256));	//vtotal
+	lt8911exb_write(dev, 0x0f, (u8) (lt8911exb->vact / 256));
+	lt8911exb_write(dev, 0x10, (u8) (lt8911exb->vact % 256));	//vactive
+	lt8911exb_write(dev, 0x11, (u8) (lt8911exb->htotal / 256));
+	lt8911exb_write(dev, 0x12, (u8) (lt8911exb->htotal % 256));	//htotal
+	lt8911exb_write(dev, 0x13, (u8) (lt8911exb->hact / 256));
+	lt8911exb_write(dev, 0x14, (u8) (lt8911exb->hact % 256));	//hactive
+	lt8911exb_write(dev, 0x15, (u8) (lt8911exb->vs % 256));	//vsa
+	lt8911exb_write(dev, 0x16, (u8) (lt8911exb->hs % 256));	//hsa
+	lt8911exb_write(dev, 0x17, (u8) (lt8911exb->vfp / 256));
+	lt8911exb_write(dev, 0x18, (u8) (lt8911exb->vfp % 256));	//vfp
+	lt8911exb_write(dev, 0x19, (u8) (lt8911exb->hfp / 256));
+	lt8911exb_write(dev, 0x1a, (u8) (lt8911exb->hfp % 256));	//hfp
+}
+
+void lt8911exb_edp_video_cfg(struct udevice *dev)
+{
+	struct lt8911exb_priv *lt8911exb = dev_get_priv(dev);
+
+	lt8911exb_write(dev, 0xff, 0xa8);
+	lt8911exb_write(dev, 0x2d, 0x88);	// MSA from register
+	lt8911exb_write(dev, 0x05, (u8) (lt8911exb->htotal / 256));
+	lt8911exb_write(dev, 0x06, (u8) (lt8911exb->htotal % 256));
+	lt8911exb_write(dev, 0x07,
+			(u8) ((lt8911exb->hs + lt8911exb->hbp) / 256));
+	lt8911exb_write(dev, 0x08,
+			(u8) ((lt8911exb->hs + lt8911exb->hbp) % 256));
+	lt8911exb_write(dev, 0x09, (u8) (lt8911exb->hs / 256));
+	lt8911exb_write(dev, 0x0a, (u8) (lt8911exb->hs % 256));
+	lt8911exb_write(dev, 0x0b, (u8) (lt8911exb->hact / 256));
+	lt8911exb_write(dev, 0x0c, (u8) (lt8911exb->hact % 256));
+	lt8911exb_write(dev, 0x0d, (u8) (lt8911exb->vtotal / 256));
+	lt8911exb_write(dev, 0x0e, (u8) (lt8911exb->vtotal % 256));
+	lt8911exb_write(dev, 0x11,
+			(u8) ((lt8911exb->vs + lt8911exb->vbp) / 256));
+	lt8911exb_write(dev, 0x12,
+			(u8) ((lt8911exb->vs + lt8911exb->vbp) % 256));
+	lt8911exb_write(dev, 0x14, (u8) (lt8911exb->vs % 256));
+	lt8911exb_write(dev, 0x15, (u8) (lt8911exb->vact / 256));
+	lt8911exb_write(dev, 0x16, (u8) (lt8911exb->vact % 256));
+
+	// lvdv de only mode to regerate h/v sync
+	lt8911exb_write(dev, 0xff, 0xd8);
+	lt8911exb_write(dev, 0x20, (u8) (lt8911exb->hfp / 256));
+	lt8911exb_write(dev, 0x21, (u8) (lt8911exb->hfp % 256));
+	lt8911exb_write(dev, 0x22, (u8) (lt8911exb->hs / 256));
+	lt8911exb_write(dev, 0x23, (u8) (lt8911exb->hs % 256));
+	lt8911exb_write(dev, 0x24, (u8) (lt8911exb->htotal / 256));
+	lt8911exb_write(dev, 0x25, (u8) (lt8911exb->htotal % 256));
+	lt8911exb_write(dev, 0x26, (u8) (lt8911exb->vfp % 256));
+	lt8911exb_write(dev, 0x27, (u8) (lt8911exb->vs % 256));
+
+	// de-sscpll to generate pixel clock for pattern
+	u8 dessc_m;
+	dessc_m = (lt8911exb->pclk * 4) / (25 * 1000);
+	lt8911exb_write(dev, 0xff, 0x85);
+	lt8911exb_write(dev, 0xaa, dessc_m);
+}
+
+void lt8911exb_setup(struct udevice *dev)
+{
+	u8 i;
+	u8 pcr_pll_postdiv;
+	u8 pcr_m;
+	u16 temp16;
+	struct lt8911exb_priv *lt8911exb = dev_get_priv(dev);
+
+	/* init */
+	lt8911exb_write(dev, 0xff, 0x81);
+	lt8911exb_write(dev, 0x08, 0x7f);    //i2c over aux issue
+	lt8911exb_write(dev, 0x49, 0xff);	//enable 0x87xx
+
+	lt8911exb_write(dev, 0xff, 0x82);	//GPIO test output
+	lt8911exb_write(dev, 0x5a, 0x0e);
+
+	/* power consumption */
+	lt8911exb_write(dev, 0xff, 0x81);
+	lt8911exb_write(dev, 0x05, 0x06);
+	lt8911exb_write(dev, 0x43, 0x00);
+	lt8911exb_write(dev, 0x44, 0x1f);
+	lt8911exb_write(dev, 0x45, 0xf7);
+	lt8911exb_write(dev, 0x46, 0xf6);
+	lt8911exb_write(dev, 0x49, 0x7f);
+
+	lt8911exb_write(dev, 0xff, 0x82);
+	lt8911exb_write(dev, 0x12, 0x33);
+
+	/* mipi Rx analog */
+	lt8911exb_write(dev, 0xff, 0x82);
+	lt8911exb_write(dev, 0x32, 0x51);
+	lt8911exb_write(dev, 0x35, 0x62);	//EQ current 0x42
+	lt8911exb_write(dev, 0x3a, 0x33); // 0x77:EQ 12.5db ,0x33:EQ 6.5db
+	lt8911exb_write(dev, 0x3b, 0x33); // 0x77:EQ 12.5db ,0x33:EQ 6.5db
+	lt8911exb_write(dev, 0x4c, 0x0c);
+	lt8911exb_write(dev, 0x4d, 0x00);
+
+	/* dessc_pcr  pll analog */
+	lt8911exb_write(dev, 0xff, 0x82);
+	lt8911exb_write(dev, 0x6a, 0x43); // final setting 0x40
+	lt8911exb_write(dev, 0x6b, 0x40); // 0x44:pre-div = 2, 0x40: pre-div = 1
+
+	temp16 = lt8911exb->pclk;
+
+	if (lt8911exb->pclk < 8800) {
+		lt8911exb_write(dev, 0x6e, 0x82);	//0x44:pre-div = 2 ,pixel_clk=44~ 88MHz
+		pcr_pll_postdiv = 0x08;
+	} else {
+		lt8911exb_write(dev, 0x6e, 0x81);	//0x40:pre-div = 1, pixel_clk =88~176MHz
+		pcr_pll_postdiv = 0x04;
+	}
+
+	pcr_m = (u8) (temp16 * pcr_pll_postdiv / 25 / 100);
+
+	/* dessc pll digital */
+	lt8911exb_write(dev, 0xff, 0x85);
+	lt8911exb_write(dev, 0xa9, 0x31);
+	lt8911exb_write(dev, 0xaa, 0x17);
+	lt8911exb_write(dev, 0xab, 0xba);
+	lt8911exb_write(dev, 0xac, 0xe1);
+	lt8911exb_write(dev, 0xad, 0x47);
+	lt8911exb_write(dev, 0xae, 0x01);
+	lt8911exb_write(dev, 0xae, 0x11);
+
+	/* Digital Top */
+	lt8911exb_write(dev, 0xff, 0x85);
+	lt8911exb_write(dev, 0xc0, 0x01);	//select mipi Rx
+#ifdef _6bit_
+	lt8911exb_write(dev, 0xb0, 0xd0);	//enable dither
+#else
+	lt8911exb_write(dev, 0xb0, 0x00);	// disable dither
+#endif
+
+	/* mipi Rx Digital */
+	lt8911exb_write(dev, 0xff, 0xd0);
+	//lt8911exb_write(dev, 0x00, lt8911exb->mipi_lane % 4);	// 0: 4 Lane / 1: 1 Lane / 2 : 2 Lane / 3: 3 Lane
+	lt8911exb_write(dev, 0x02, 0x08);	//settle
+	lt8911exb_write(dev, 0x08, 0x00);
+
+	lt8911exb_write(dev, 0x0c, 0x80); // fifo position
+	lt8911exb_write(dev, 0x1c, 0x80); // fifo position
+	lt8911exb_write(dev, 0x24, 0x70); // pcr mode (de hs vs)
+
+	lt8911exb_write(dev, 0x31, 0x0a); // M down limit
+
+	// stage1 hs mode */
+	lt8911exb_write(dev, 0x25, 0x90); // line limit
+	lt8911exb_write(dev, 0x2a, 0x3a); // step in limit
+	lt8911exb_write(dev, 0x21, 0x4f); // hs_step
+	lt8911exb_write(dev, 0x22, 0xff);
+
+	// stage2 de mode */
+	lt8911exb_write(dev, 0x0a, 0x02); // de adjust pre line
+	lt8911exb_write(dev, 0x38, 0x02); // de threshold 1
+	lt8911exb_write(dev, 0x39, 0x04); // de threshold 2
+	lt8911exb_write(dev, 0x3a, 0x08); // de threshold 3
+	lt8911exb_write(dev, 0x3b, 0x10); // de threshold 4
+
+	lt8911exb_write(dev, 0x3f, 0x02); // de_step 1
+	lt8911exb_write(dev, 0x40, 0x04); // de_step 2
+	lt8911exb_write(dev, 0x41, 0x08); // de_step 3
+	lt8911exb_write(dev, 0x42, 0x10); // de_step 4
+
+	// stage 2 hs mode */
+	lt8911exb_write(dev, 0x1e, 0x01); // hs threshold
+	lt8911exb_write(dev, 0x23, 0xf0); // hs step
+
+	lt8911exb_write(dev, 0x2b, 0x80); // stable out // V1.8 20200417
+
+	if (lt8911exb->test) {
+		lt8911exb_write(dev, 0x26, (pcr_m | 0x80));
+	} else {
+		lt8911exb_write(dev, 0x26, pcr_m);
+	}
+
+	lt8911exb_mipi_video_timing(dev);	//defualt setting is 1080P
+
+	lt8911exb_write(dev, 0xff, 0x81);	//PCR reset
+	lt8911exb_write(dev, 0x03, 0x7b);
+	lt8911exb_write(dev, 0x03, 0xff);
+
+	/* Txpll 2.7G */
+	lt8911exb_write(dev, 0xff, 0x87);
+	lt8911exb_write(dev, 0x19, 0x31);
+	lt8911exb_write(dev, 0x1a, 0x1b);
+	lt8911exb_write(dev, 0xff, 0x82);
+	lt8911exb_write(dev, 0x02, 0x42);
+	lt8911exb_write(dev, 0x03, 0x00);
+	lt8911exb_write(dev, 0x03, 0x01);
+	lt8911exb_write(dev, 0x0a, 0x1b);
+	lt8911exb_write(dev, 0x04, 0x2a);
+	lt8911exb_write(dev, 0xff, 0x81);
+	lt8911exb_write(dev, 0x09, 0xfc);
+	lt8911exb_write(dev, 0x09, 0xfd);
+	lt8911exb_write(dev, 0xff, 0x87);
+	lt8911exb_write(dev, 0x0c, 0x11);
+
+	for (i = 0; i < 5; i++) {	//Check Tx PLL
+		mdelay(5);
+
+		if (lt8911exb_read(dev, 0x37) & 0x02) {
+			printf( "LT8911 tx pll locked\n\r");
+			lt8911exb_write(dev, 0xff, 0x87);
+			lt8911exb_write(dev, 0x1a, 0x36);
+			lt8911exb_write(dev, 0xff, 0x82);
+			lt8911exb_write(dev, 0x0a, 0x36);
+			lt8911exb_write(dev, 0x04, 0x3a);
+			break;
+		} else {
+			printf( "LT8911 tx pll unlocked\n\r");
+			lt8911exb_write(dev, 0xff, 0x81);
+			lt8911exb_write(dev, 0x09, 0xfc);
+			lt8911exb_write(dev, 0x09, 0xfd);
+			lt8911exb_write(dev, 0xff, 0x87);
+			lt8911exb_write(dev, 0x0c, 0x10);
+			lt8911exb_write(dev, 0x0c, 0x11);
+		}
+	}
+
+	/* tx phy */
+	lt8911exb_write(dev, 0xff, 0x82);
+	lt8911exb_write(dev, 0x11, 0x00);
+	lt8911exb_write(dev, 0x13, 0x10);
+	lt8911exb_write(dev, 0x14, 0x0c);
+	lt8911exb_write(dev, 0x14, 0x08);
+	lt8911exb_write(dev, 0x13, 0x20);
+	lt8911exb_write(dev, 0xff, 0x82);
+	lt8911exb_write(dev, 0x0e, 0x25);
+	//lt8911exb_write(dev, 0x12, 0xff);
+	lt8911exb_write(dev, 0xff, 0x80);
+	lt8911exb_write(dev, 0x40, 0x22);
+
+	/*eDP Tx Digital */
+	lt8911exb_write(dev, 0xff, 0xa8);
+	if (lt8911exb->test) {
+		// 0x52 双色方块交错
+		// 0x53 竖着的双色条幅
+		// 0x54 横着的双色条幅
+		// 0x55 有间距的方块
+		lt8911exb_write(dev, 0x24, 0x52); // bit2 ~ bit 0 : test panttern image mode
+		// bit 6 Red
+		// bit 5 Green
+		// bit 4 Blue
+		lt8911exb_write(dev, 0x25, 0b01110000);  // bit6 ~ bit 4 : test Pattern color
+		lt8911exb_write(dev, 0x27, 0x50);	//0x50:Pattern; 0x10:mipi video
+	} else {
+		lt8911exb_write(dev, 0x27, 0x10);	//0x50:Pattern; 0x10:mipi video
+	}
+
+	if (lt8911exb->color) {
+		//8bit
+		//lt8911exb_write(dev, 0x17, 0x10);
+		//lt8911exb_write(dev, 0x18, 0x20);
+	} else {
+		//6bit
+		lt8911exb_write(dev, 0x17, 0x00);
+		lt8911exb_write(dev, 0x18, 0x00);
+	}
+
+	lt8911exb_write(dev, 0xff, 0xa0); // nvid = 0x080000;
+	lt8911exb_write(dev, 0x00, 0x08);
+	lt8911exb_write(dev, 0x01, 0x80);
+}
+
+/* mipi should be ready before configuring below video check setting*/
+void lt8911exb_video_check(struct udevice *dev)
+{
+	u32 ret = 0x00;
+
+	/* mipi byte clk check */
+	lt8911exb_write(dev, 0xff, 0x85);
+	lt8911exb_write(dev, 0x1d, 0x00);	//FM select byte clk
+	lt8911exb_write(dev, 0x40, 0xf7);
+	lt8911exb_write(dev, 0x41, 0x30);
+	lt8911exb_write(dev, 0xa1, 0x02);	//video chech from mipi
+
+	//  lt8911exb_write(dev, 0x17, 0xf0 ); //0xf0:Close scramble; 0xD0 : Open scramble
+
+	lt8911exb_write(dev, 0xff, 0x81);	//video check rst
+	lt8911exb_write(dev, 0x09, 0x7d);
+	lt8911exb_write(dev, 0x09, 0xfd);
+
+	lt8911exb_write(dev, 0xff, 0x85);
+	mdelay(100);
+
+	if (lt8911exb_read(dev, 0x50) == 0x03) {
+		ret = lt8911exb_read(dev, 0x4d);
+		ret = ret * 256 + lt8911exb_read(dev, 0x4e);
+		ret = ret * 256 + lt8911exb_read(dev, 0x4f);
+
+		printf( "video check: mipi clk = %d\n\r", ret);	//mipi clk = ret * 1000
+	} else {
+		printf( "video check: mipi clk unstable\n\r");
+	}
+
+	/* mipi vtotal check */
+	ret = lt8911exb_read(dev, 0x76);
+	ret = ret * 256 + lt8911exb_read(dev, 0x77);
+
+	printf( "video check: Vtotal = %d\n\r", ret);
+
+	/* mipi word count check */
+	lt8911exb_write(dev, 0xff, 0xd0);
+	ret = lt8911exb_read(dev, 0x82);
+	ret = ret * 256 + lt8911exb_read(dev, 0x83);
+	ret = ret / 3;
+
+	printf( "video check: Hact(word counter) = %d\n\r", ret);
+
+	/* mipi Vact check */
+	ret = lt8911exb_read(dev, 0x85);
+	ret = ret * 256 + lt8911exb_read(dev, 0x86);
+
+	printf( "video check: Vact = %d\n\r", ret);
+	printf( "lane0 settle: 0x%02x\n\r", lt8911exb_read(dev, 0x88));
+	printf( "lane1 settle: 0x%02x\n\r", lt8911exb_read(dev, 0x8a));
+	printf( "lane2 settle: 0x%02x\n\r", lt8911exb_read(dev, 0x8c));
+	printf( "lane3 settle: 0x%02x\n\r", lt8911exb_read(dev, 0x8e));
+
+	printf( "lane0 sot: 0x%02x\n\r", lt8911exb_read(dev, 0x89));
+	printf( "lane1 sot: 0x%02x\n\r", lt8911exb_read(dev, 0x8b));
+	printf( "lane2 sot: 0x%02x\n\r", lt8911exb_read(dev, 0x8d));
+	printf( "lane3 sot: 0x%02x\n\r", lt8911exb_read(dev, 0x8f));
+}
+
+#define SCRAMBLE_MODE 0x00 // 0x80:edp, 0x00:dp
+#define MSA_SW_MODE 0x80 // MSA from register
+#define MSA_HW_MODE 0x00 // MSA from video check
+#define EDP_IDLE_PTN_ON 0x04
+#define EDP_IDLE_PTN_OFF 0x00
+#define LANE_CNT 2
+
+void lt8911exb_link_train(struct udevice *dev)
+{
+	struct lt8911exb_priv *lt8911exb = dev_get_priv(dev);
+
+	if (SCRAMBLE_MODE == 0x80) {
+		lt8911exb_dpcd_write(dev, 0x10a, 0x01);
+	}
+
+	lt8911exb_write(dev, 0xff, 0xa6);
+	lt8911exb_write(dev, 0x2a, 0x00);
+
+	lt8911exb_write(dev, 0xff, 0x81);
+	lt8911exb_write(dev, 0x07, 0xfe);
+	lt8911exb_write(dev, 0x07, 0xff);
+	lt8911exb_write(dev, 0x0a, 0xfc);
+	lt8911exb_write(dev, 0x0a, 0xfe);
+
+	// link train
+	lt8911exb_write(dev, 0xff, 0xa8);
+	lt8911exb_write(dev, 0x2d, MSA_SW_MODE | EDP_IDLE_PTN_OFF); // edp output video
+
+	lt8911exb_write(dev, 0xff, 0x85);
+	lt8911exb_write(dev, 0x17, 0xc0);
+	lt8911exb_write(dev, 0x1a, LANE_CNT);
+	lt8911exb_write(dev, 0xa1, (SCRAMBLE_MODE | 0x03)); // scramble mode
+
+	lt8911exb_write(dev, 0xff, 0xac);
+	lt8911exb_write(dev, 0x00, 0x60);
+	lt8911exb_write(dev, 0x01, 0x0a);
+	lt8911exb_write(dev, 0x0c, 0x05);
+	lt8911exb_write(dev, 0x0c, 0x45);
+	printf( "link train: hardware linktrain start\n\r");
+	mdelay(500);
+}
+
+void lt8911exb_main(struct udevice *dev)
+{
+	u16 reg;
+	u16 vtotal;
+
+	struct lt8911exb_priv *lt8911exb = dev_get_priv(dev);
+	vtotal = lt8911exb->vtotal;
+	lt8911exb_write(dev, 0xff, 0x85);
+	lt8911exb_write(dev, 0xa1, 0x02); // video chech from mipi
+	lt8911exb_write(dev, 0xff, 0x81); // video check rst
+	lt8911exb_write(dev, 0x09, 0x7d);
+	lt8911exb_write(dev, 0x09, 0xfd);
+	mdelay(100);
+
+	lt8911exb_write(dev, 0xff, 0x85);
+	reg = lt8911exb_read(dev, 0x76);
+	reg = reg * 256 + lt8911exb_read(dev, 0x77);
+
+	if ((reg <= (vtotal + 3)) && (reg >= (vtotal - 3))) {
+		mdelay(1000);
+		lt8911exb_write(dev, 0xff, 0x81); // pcr reset
+		lt8911exb_write(dev, 0x03, 0x7b);
+		lt8911exb_write(dev, 0x03, 0xff);
+		mdelay(100);
+		lt8911exb_write(dev, 0xff, 0xa8);
+		lt8911exb_write(dev, 0x2d, 0x88); // edp disable idle pattern;
+		printf( "PCR reset0\n\r");
+		lt8911exb_write(dev, 0xff, 0xd0);
+		if ((lt8911exb_read(dev, 0x84) & 0x40) == 0x00) {
+			lt8911exb_write(dev, 0xff, 0x81); // pcr reset
+			lt8911exb_write(dev, 0x03, 0x7b);
+			lt8911exb_write(dev, 0x03, 0xff);
+			mdelay(500);
+			printf( "PCR reset1\n\r");
+		}
+		lt8911exb_write(dev, 0xff, 0xd0);
+	}
+}
+
+void lt8911exb_config(struct udevice *dev)
+{
+	lt8911exb_edp_video_cfg(dev);
+	lt8911exb_setup(dev);
+	lt8911exb_link_train(dev);
+	lt8911exb_video_check(dev);	//just for Check MIPI Input
+	lt8911exb_main(dev);
+}
+
+static int lt8911exb_enable(struct udevice *dev)
+{
+	int ret, i;
+
+	/* Deassert reset and enable power */
+	ret = video_bridge_set_active(dev, true);
+	if (ret)
+		return ret;
+
+	lt8911exb_parse_dt(dev);
+	lt8911exb_config(dev);
+
+	return 0;
+}
+
+static int lt8911exb_probe(struct udevice *dev)
+{
+	if (device_get_uclass_id(dev->parent) != UCLASS_I2C)
+		return -EPROTONOSUPPORT;
+
+	return lt8911exb_enable(dev);
+}
+
+struct video_bridge_ops lt8911exb_ops = {
+	.attach = lt8911exb_attach,
+	.set_backlight = lt8911exb_set_backlight,
+};
+
+static const struct udevice_id lt8911exb_ids[] = {
+	{ .compatible = "lontium,lt8911exb", },
+	{ }
+};
+
+U_BOOT_DRIVER(analogix_lt8911exb) = {
+	.name	= "analogix_lt8911exb",
+	.id	= UCLASS_VIDEO_BRIDGE,
+	.of_match = lt8911exb_ids,
+	.probe	= lt8911exb_probe,
+	.ops	= &lt8911exb_ops,
+	.priv_auto_alloc_size = sizeof(struct lt8911exb_priv),
+};
diff --git a/drivers/video/bridge/lt8911exb.ce b/drivers/video/bridge/lt8911exb.ce
new file mode 100644
index 00000000..d78a4579
--- /dev/null
+++ b/drivers/video/bridge/lt8911exb.ce
@@ -0,0 +1,422 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2017 Vasily Khoruzhick <anarsoul@gmail.com>
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <edid.h>
+#include <video_bridge.h>
+#include "../anx98xx-edp.h"
+
+#define DP_MAX_LINK_RATE		0x001
+#define DP_MAX_LANE_COUNT		0x002
+#define DP_MAX_LANE_COUNT_MASK		0x1f
+
+struct anx6345_priv {
+	u8 edid[EDID_SIZE];
+};
+
+static int anx6345_write(struct udevice *dev, unsigned int addr_off,
+			 unsigned char reg_addr, unsigned char value)
+{
+	uint8_t buf[2];
+	struct i2c_msg msg;
+	int ret;
+
+	msg.addr = addr_off;
+	msg.flags = 0;
+	buf[0] = reg_addr;
+	buf[1] = value;
+	msg.buf = buf;
+	msg.len = 2;
+	ret = dm_i2c_xfer(dev, &msg, 1);
+	if (ret) {
+		debug("%s: write failed, reg=%#x, value=%#x, ret=%d\n",
+		      __func__, reg_addr, value, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int anx6345_read(struct udevice *dev, unsigned int addr_off,
+			unsigned char reg_addr, unsigned char *value)
+{
+	uint8_t addr, val;
+	struct i2c_msg msg[2];
+	int ret;
+
+	msg[0].addr = addr_off;
+	msg[0].flags = 0;
+	addr = reg_addr;
+	msg[0].buf = &addr;
+	msg[0].len = 1;
+	msg[1].addr = addr_off;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = &val;
+	msg[1].len = 1;
+	ret = dm_i2c_xfer(dev, msg, 2);
+	if (ret) {
+		debug("%s: read failed, reg=%.2x, value=%p, ret=%d\n",
+		      __func__, (int)reg_addr, value, ret);
+		return ret;
+	}
+	*value = val;
+
+	return 0;
+}
+
+static int anx6345_write_r0(struct udevice *dev, unsigned char reg_addr,
+			    unsigned char value)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+
+	return anx6345_write(dev, chip->chip_addr, reg_addr, value);
+}
+
+static int anx6345_read_r0(struct udevice *dev, unsigned char reg_addr,
+			   unsigned char *value)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+
+	return anx6345_read(dev, chip->chip_addr, reg_addr, value);
+}
+
+static int anx6345_write_r1(struct udevice *dev, unsigned char reg_addr,
+			    unsigned char value)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+
+	return anx6345_write(dev, chip->chip_addr + 1, reg_addr, value);
+}
+
+static int anx6345_read_r1(struct udevice *dev, unsigned char reg_addr,
+			   unsigned char *value)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+
+	return anx6345_read(dev, chip->chip_addr + 1, reg_addr, value);
+}
+
+static int anx6345_set_backlight(struct udevice *dev, int percent)
+{
+	return -ENOSYS;
+}
+
+static int anx6345_aux_wait(struct udevice *dev)
+{
+	int ret = -ETIMEDOUT;
+	u8 v;
+	int retries = 1000;
+
+	do {
+		anx6345_read_r0(dev, ANX9804_DP_AUX_CH_CTL_2, &v);
+		if (!(v & ANX9804_AUX_EN)) {
+			ret = 0;
+			break;
+		}
+		udelay(100);
+	} while (retries--);
+
+	if (ret) {
+		debug("%s: timed out waiting for AUX_EN to clear\n", __func__);
+		return ret;
+	}
+
+	ret = -ETIMEDOUT;
+	retries = 1000;
+	do {
+		anx6345_read_r1(dev, ANX9804_DP_INT_STA, &v);
+		if (v & ANX9804_RPLY_RECEIV) {
+			ret = 0;
+			break;
+		}
+		udelay(100);
+	} while (retries--);
+
+	if (ret) {
+		debug("%s: timed out waiting to receive reply\n", __func__);
+		return ret;
+	}
+
+	/* Clear RPLY_RECEIV bit */
+	anx6345_write_r1(dev, ANX9804_DP_INT_STA, v);
+
+	anx6345_read_r0(dev, ANX9804_AUX_CH_STA, &v);
+	if ((v & ANX9804_AUX_STATUS_MASK) != 0) {
+		debug("AUX status: %d\n", v & ANX9804_AUX_STATUS_MASK);
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+static void anx6345_aux_addr(struct udevice *dev, u32 addr)
+{
+	u8 val;
+
+	val = addr & 0xff;
+	anx6345_write_r0(dev, ANX9804_DP_AUX_ADDR_7_0, val);
+	val = (addr >> 8) & 0xff;
+	anx6345_write_r0(dev, ANX9804_DP_AUX_ADDR_15_8, val);
+	val = (addr >> 16) & 0x0f;
+	anx6345_write_r0(dev, ANX9804_DP_AUX_ADDR_19_16, val);
+}
+
+static int anx6345_aux_transfer(struct udevice *dev, u8 req,
+				u32 addr, u8 *buf, size_t len)
+{
+	int i, ret;
+	u8 ctrl1 = req;
+	u8 ctrl2 = ANX9804_AUX_EN;
+
+	if (len > 16)
+		return -E2BIG;
+
+	if (len)
+		ctrl1 |= ANX9804_AUX_LENGTH(len);
+	else
+		ctrl2 |= ANX9804_ADDR_ONLY;
+
+	if (len && !(req & ANX9804_AUX_TX_COMM_READ)) {
+		for (i = 0; i < len; i++)
+			anx6345_write_r0(dev, ANX9804_BUF_DATA_0 + i, buf[i]);
+	}
+
+	anx6345_aux_addr(dev, addr);
+	anx6345_write_r0(dev, ANX9804_DP_AUX_CH_CTL_1, ctrl1);
+	anx6345_write_r0(dev, ANX9804_DP_AUX_CH_CTL_2, ctrl2);
+	ret = anx6345_aux_wait(dev);
+	if (ret) {
+		debug("AUX transaction timed out\n");
+		return ret;
+	}
+
+	if (len && (req & ANX9804_AUX_TX_COMM_READ)) {
+		for (i = 0; i < len; i++)
+			anx6345_read_r0(dev, ANX9804_BUF_DATA_0 + i, &buf[i]);
+	}
+
+	return 0;
+}
+
+static int anx6345_read_aux_i2c(struct udevice *dev, u8 chip_addr,
+				u8 offset, size_t count, u8 *buf)
+{
+	int i, ret;
+	size_t cur_cnt;
+	u8 cur_offset;
+
+	for (i = 0; i < count; i += 16) {
+		cur_cnt = (count - i) > 16 ? 16 : count - i;
+		cur_offset = offset + i;
+		ret = anx6345_aux_transfer(dev, ANX9804_AUX_TX_COMM_MOT,
+					   chip_addr, &cur_offset, 1);
+		if (ret) {
+			debug("%s: failed to set i2c offset: %d\n",
+			      __func__, ret);
+			return ret;
+		}
+		ret = anx6345_aux_transfer(dev, ANX9804_AUX_TX_COMM_READ,
+					   chip_addr, buf + i, cur_cnt);
+		if (ret) {
+			debug("%s: failed to read from i2c device: %d\n",
+			      __func__, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int anx6345_read_dpcd(struct udevice *dev, u32 reg, u8 *val)
+{
+	int ret;
+
+	ret = anx6345_aux_transfer(dev,
+				   ANX9804_AUX_TX_COMM_READ |
+				   ANX9804_AUX_TX_COMM_DP_TRANSACTION,
+				   reg, val, 1);
+	if (ret) {
+		debug("Failed to read DPCD\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int anx6345_read_edid(struct udevice *dev, u8 *buf, int size)
+{
+	struct anx6345_priv *priv = dev_get_priv(dev);
+
+	if (size > EDID_SIZE)
+		size = EDID_SIZE;
+	memcpy(buf, priv->edid, size);
+
+	return size;
+}
+
+static int anx6345_attach(struct udevice *dev)
+{
+	/* No-op */
+	return 0;
+}
+
+static int anx6345_enable(struct udevice *dev)
+{
+	u8 chipid, colordepth, lanes, data_rate, c;
+	int ret, i, bpp;
+	struct display_timing timing;
+	struct anx6345_priv *priv = dev_get_priv(dev);
+
+	/* Deassert reset and enable power */
+	ret = video_bridge_set_active(dev, true);
+	if (ret)
+		return ret;
+
+	/* Reset */
+	anx6345_write_r1(dev, ANX9804_RST_CTRL_REG, 1);
+	mdelay(100);
+	anx6345_write_r1(dev, ANX9804_RST_CTRL_REG, 0);
+
+	/* Write 0 to the powerdown reg (powerup everything) */
+	anx6345_write_r1(dev, ANX9804_POWERD_CTRL_REG, 0);
+
+	ret = anx6345_read_r1(dev, ANX9804_DEV_IDH_REG, &chipid);
+	if (ret)
+		debug("%s: read id failed: %d\n", __func__, ret);
+
+	switch (chipid) {
+	case 0x63:
+		debug("ANX63xx detected.\n");
+		break;
+	default:
+		debug("Error anx6345 chipid mismatch: %.2x\n", (int)chipid);
+		return -ENODEV;
+	}
+
+	for (i = 0; i < 100; i++) {
+		anx6345_read_r0(dev, ANX9804_SYS_CTRL2_REG, &c);
+		anx6345_write_r0(dev, ANX9804_SYS_CTRL2_REG, c);
+		anx6345_read_r0(dev, ANX9804_SYS_CTRL2_REG, &c);
+		if ((c & ANX9804_SYS_CTRL2_CHA_STA) == 0)
+			break;
+
+		mdelay(5);
+	}
+	if (i == 100)
+		debug("Error anx6345 clock is not stable\n");
+
+	/* Set a bunch of analog related register values */
+	anx6345_write_r0(dev, ANX9804_PLL_CTRL_REG, 0x00);
+	anx6345_write_r1(dev, ANX9804_ANALOG_DEBUG_REG1, 0x70);
+	anx6345_write_r0(dev, ANX9804_LINK_DEBUG_REG, 0x30);
+
+	/* Force HPD */
+	anx6345_write_r0(dev, ANX9804_SYS_CTRL3_REG,
+			 ANX9804_SYS_CTRL3_F_HPD | ANX9804_SYS_CTRL3_HPD_CTRL);
+
+	/* Power up and configure lanes */
+	anx6345_write_r0(dev, ANX9804_ANALOG_POWER_DOWN_REG, 0x00);
+	anx6345_write_r0(dev, ANX9804_TRAINING_LANE0_SET_REG, 0x00);
+	anx6345_write_r0(dev, ANX9804_TRAINING_LANE1_SET_REG, 0x00);
+	anx6345_write_r0(dev, ANX9804_TRAINING_LANE2_SET_REG, 0x00);
+	anx6345_write_r0(dev, ANX9804_TRAINING_LANE3_SET_REG, 0x00);
+
+	/* Reset AUX CH */
+	anx6345_write_r1(dev, ANX9804_RST_CTRL2_REG,
+			 ANX9804_RST_CTRL2_AUX);
+	anx6345_write_r1(dev, ANX9804_RST_CTRL2_REG, 0);
+
+	/* Powerdown audio and some other unused bits */
+	anx6345_write_r1(dev, ANX9804_POWERD_CTRL_REG, ANX9804_POWERD_AUDIO);
+	anx6345_write_r0(dev, ANX9804_HDCP_CONTROL_0_REG, 0x00);
+	anx6345_write_r0(dev, 0xa7, 0x00);
+
+	anx6345_read_aux_i2c(dev, 0x50, 0x0, EDID_SIZE, priv->edid);
+	if (edid_get_timing(priv->edid, EDID_SIZE, &timing, &bpp) != 0) {
+		debug("Failed to parse EDID\n");
+		return -EIO;
+	}
+	debug("%s: panel found: %dx%d, bpp %d\n", __func__,
+	      timing.hactive.typ, timing.vactive.typ, bpp);
+	if (bpp == 6)
+		colordepth = 0x00; /* 6 bit */
+	else
+		colordepth = 0x10; /* 8 bit */
+	anx6345_write_r1(dev, ANX9804_VID_CTRL2_REG, colordepth);
+
+	if (anx6345_read_dpcd(dev, DP_MAX_LINK_RATE, &data_rate)) {
+		debug("%s: Failed to DP_MAX_LINK_RATE\n", __func__);
+		return -EIO;
+	}
+	debug("%s: data_rate: %d\n", __func__, (int)data_rate);
+	if (anx6345_read_dpcd(dev, DP_MAX_LANE_COUNT, &lanes)) {
+		debug("%s: Failed to read DP_MAX_LANE_COUNT\n", __func__);
+		return -EIO;
+	}
+	lanes &= DP_MAX_LANE_COUNT_MASK;
+	debug("%s: lanes: %d\n", __func__, (int)lanes);
+
+	/* Set data-rate / lanes */
+	anx6345_write_r0(dev, ANX9804_LINK_BW_SET_REG, data_rate);
+	anx6345_write_r0(dev, ANX9804_LANE_COUNT_SET_REG, lanes);
+
+	/* Link training */
+	anx6345_write_r0(dev, ANX9804_LINK_TRAINING_CTRL_REG,
+			 ANX9804_LINK_TRAINING_CTRL_EN);
+	mdelay(5);
+	for (i = 0; i < 100; i++) {
+		anx6345_read_r0(dev, ANX9804_LINK_TRAINING_CTRL_REG, &c);
+		if ((chipid == 0x63) && (c & 0x80) == 0)
+			break;
+
+		mdelay(5);
+	}
+	if (i == 100) {
+		debug("Error anx6345 link training timeout\n");
+		return -ENODEV;
+	}
+
+	/* Enable */
+	anx6345_write_r1(dev, ANX9804_VID_CTRL1_REG,
+			 ANX9804_VID_CTRL1_VID_EN | ANX9804_VID_CTRL1_EDGE);
+	/* Force stream valid */
+	anx6345_write_r0(dev, ANX9804_SYS_CTRL3_REG,
+			 ANX9804_SYS_CTRL3_F_HPD |
+			 ANX9804_SYS_CTRL3_HPD_CTRL |
+			 ANX9804_SYS_CTRL3_F_VALID |
+			 ANX9804_SYS_CTRL3_VALID_CTRL);
+
+	return 0;
+}
+
+static int anx6345_probe(struct udevice *dev)
+{
+	if (device_get_uclass_id(dev->parent) != UCLASS_I2C)
+		return -EPROTONOSUPPORT;
+
+	return anx6345_enable(dev);
+}
+
+struct video_bridge_ops anx6345_ops = {
+	.attach = anx6345_attach,
+	.read_edid = anx6345_read_edid,
+};
+
+static const struct udevice_id anx6345_ids[] = {
+	{ .compatible = "lon,anx6345", },
+	{ }
+};
+
+U_BOOT_DRIVER(analogix_anx6345) = {
+	.name	= "analogix_anx6345",
+	.id	= UCLASS_VIDEO_BRIDGE,
+	.of_match = anx6345_ids,
+	.probe	= anx6345_probe,
+	.ops	= &anx6345_ops,
+	.priv_auto_alloc_size = sizeof(struct anx6345_priv),
+};
-- 
2.34.1

